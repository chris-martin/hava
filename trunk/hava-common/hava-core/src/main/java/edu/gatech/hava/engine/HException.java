package edu.gatech.hava.engine;

import java.util.List;

import edu.gatech.hava.engine.exception.ExceptionEnvironment;
import edu.gatech.hava.engine.exception.ImportRec;
import edu.gatech.hava.parser.ParseException;
import edu.gatech.hava.parser.Token;
import edu.gatech.hava.parser.TokenMgrError;

/**
 * Exception generated by the Hava engine, showing the line and column of the
 * source where the failure occurred.
 */
public class HException extends Exception {

    private static final long serialVersionUID = 1L;

    /**
     * A rather generic message indicating a syntax problem.
     */
    public static final String SYNTAX_MESSAGE = "Incorrect syntax.";

    /**
     * The catch-all error message "Type mismatch".
     */
    public static final String TYPE_MESSAGE = "Type mismatch.";

    /**
     * An error message indicating an attempt to divide by zero.
     */
    public static final String DIVIDE_BY_ZERO_MESSAGE = "Division by zero";

    private final ExceptionEnvironment env;

    private String file;
    private int line;
    private int column;

    HException(final ExceptionEnvironment env) {

        this.env = env;

    }

    public HException(final String message,
                      final ExceptionEnvironment env) {

        super(message);

        this.env = env;

        initialize(env.getErrorLocation());

    }

    HException(final Throwable x,
               final ExceptionEnvironment env) {

        super(createMessage(x));

        this.env = env;

        initialize(x);

    }

    HException(final Throwable x,
               final ExceptionEnvironment env,
               final String errorFile) {

        this(x, env);
        file = errorFile;

    }

    /**
     * @return Number of line where error occurred.
     */
    public int getLine() {

        return line;

    }

    /**
     * @return Number of column where error occurred.
     */
    public int getColumn() {

        return column;

    }

    /**
     * @return Name of import file where error occurred.
     */
    public String getFile() {

        return file;

    }

    void setFile(final String file) {

        this.file = file;

    }

    private static String createMessage(final Throwable x) {

        if (x instanceof TokenMgrError) {

            String s = x.getMessage();
            if (!s.startsWith("Lexical")) {
                return s;
            }
            int k = s.indexOf(".");
            return s.substring(0, k + 1);

        }

        if (x instanceof ParseException) {
            return SYNTAX_MESSAGE;
        }

        if (x instanceof StackOverflowError) {
            return "Maximum recursion depth exceeded.";
        }

        if (x instanceof OutOfMemoryError) {
            return "Out of memory.";
        }

        return "Unknown run-time error.";

    }

    private void initialize(Token t) {

        if (t.next != null) {
            line = t.beginLine;
            column = t.beginColumn;
        } else {
            line = t.endLine;
            column = t.endColumn + 1;
        }

        if (line < 1) {
            line = 1;
            column = 1;
        }

        while (t.next != null) {
            t = t.next;
        }

        final List<ImportRec> importList = env.getImportList();

        if (importList != null) {
            for (ImportRec r : importList) {
                if (t == r.getRoot().jjtGetLastToken()) {
                    file = r.getIdentifier();
                    break;
                }
            }
        }

    }

    private void initialize(final Throwable x) {

        line = 0;
        column = 0;
        file = null;

        if (x instanceof ParseException) {

            initialize(((ParseException) x).currentToken);

        } else {

            final List<ImportRec> importList = env.getImportList();

            if (importList != null) {
                final ImportRec r = importList.get(importList.size() - 1);
                file = r.getIdentifier();
            }

        }

    }

}
